{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\n/* eslint no-loop-func: 0*/\n\nimport React from 'react';\nexport function getValuePropValue(child) {\n  var props = child.props;\n\n  if ('value' in props) {\n    return props.value;\n  }\n\n  if (child.key) {\n    return child.key;\n  }\n\n  throw new Error('no key or value for ' + child);\n}\nexport function getPropValue(child, prop) {\n  if (prop === 'value') {\n    return getValuePropValue(child);\n  }\n\n  return child.props[prop];\n}\nexport function isCombobox(props) {\n  return props.combobox;\n}\nexport function isMultipleOrTags(props) {\n  return !!(props.multiple || props.tags || props.treeCheckable);\n}\nexport function isMultipleOrTagsOrCombobox(props) {\n  return isMultipleOrTags(props) || isCombobox(props);\n}\nexport function isSingleMode(props) {\n  return !isMultipleOrTagsOrCombobox(props);\n}\nexport function toArray(value) {\n  var ret = value;\n\n  if (value === undefined) {\n    ret = [];\n  } else if (!Array.isArray(value)) {\n    ret = [value];\n  }\n\n  return ret;\n}\nexport function preventDefaultEvent(e) {\n  e.preventDefault();\n}\nexport var UNSELECTABLE_STYLE = {\n  userSelect: 'none',\n  WebkitUserSelect: 'none'\n};\nexport var UNSELECTABLE_ATTRIBUTE = {\n  unselectable: 'unselectable'\n};\nexport function labelCompatible(prop) {\n  var newProp = prop;\n\n  if (newProp === 'label') {\n    newProp = 'title';\n  }\n\n  return newProp;\n}\nexport function isInclude(smallArray, bigArray) {\n  // attention: [0,0,1] [0,0,10]\n  return smallArray.every(function (ii, i) {\n    return ii === bigArray[i];\n  });\n}\n/*\nexport function getCheckedKeys(node, checkedKeys, allCheckedNodesKeys) {\n  const nodeKey = node.props.eventKey;\n  let newCks = [...checkedKeys];\n  let nodePos;\n  const unCheck = allCheckedNodesKeys.some(item => {\n    if (item.key === nodeKey) {\n      nodePos = item.pos;\n      return true;\n    }\n  });\n  if (unCheck) {\n    const nArr = nodePos.split('-');\n    newCks = [];\n    allCheckedNodesKeys.forEach(item => {\n      const iArr = item.pos.split('-');\n      if (item.pos === nodePos ||\n        nArr.length > iArr.length && isInclude(iArr, nArr) ||\n        nArr.length < iArr.length && isInclude(nArr, iArr)) {\n        return;\n      }\n      newCks.push(item.key);\n    });\n  } else {\n    newCks.push(nodeKey);\n  }\n  return newCks;\n}\n*/\n\nfunction getChildrenlength(children) {\n  var len = 1;\n\n  if (Array.isArray(children)) {\n    len = children.length;\n  }\n\n  return len;\n}\n\nfunction getSiblingPosition(index, len, siblingPosition) {\n  if (len === 1) {\n    siblingPosition.first = true;\n    siblingPosition.last = true;\n  } else {\n    siblingPosition.first = index === 0;\n    siblingPosition.last = index === len - 1;\n  }\n\n  return siblingPosition;\n}\n\nexport function loopAllChildren(childs, callback, parent) {\n  var loop = function loop(children, level, _parent) {\n    var len = getChildrenlength(children);\n    React.Children.forEach(children, function handler(item, index) {\n      // eslint-disable-line\n      var pos = level + '-' + index;\n\n      if (item && item.props.children && item.type) {\n        loop(item.props.children, pos, {\n          node: item,\n          pos: pos\n        });\n      }\n\n      if (item) {\n        callback(item, index, pos, item.key || pos, getSiblingPosition(index, len, {}), _parent);\n      }\n    });\n  };\n\n  loop(childs, 0, parent);\n} // export function loopAllChildren(childs, callback) {\n//   const loop = (children, level) => {\n//     React.Children.forEach(children, (item, index) => {\n//       const pos = `${level}-${index}`;\n//       if (item && item.props.children) {\n//         loop(item.props.children, pos);\n//       }\n//       if (item) {\n//         callback(item, index, pos, getValuePropValue(item));\n//       }\n//     });\n//   };\n//   loop(childs, 0);\n// }\n\nexport function flatToHierarchy(arr) {\n  if (!arr.length) {\n    return arr;\n  }\n\n  var hierarchyNodes = [];\n  var levelObj = {};\n  arr.forEach(function (item) {\n    if (!item.pos) {\n      return;\n    }\n\n    var posLen = item.pos.split('-').length;\n\n    if (!levelObj[posLen]) {\n      levelObj[posLen] = [];\n    }\n\n    levelObj[posLen].push(item);\n  });\n  var levelArr = Object.keys(levelObj).sort(function (a, b) {\n    return b - a;\n  }); // const s = Date.now();\n  // todo: there are performance issues!\n\n  levelArr.reduce(function (pre, cur) {\n    if (cur && cur !== pre) {\n      levelObj[pre].forEach(function (item) {\n        var haveParent = false;\n        levelObj[cur].forEach(function (ii) {\n          if (isInclude(ii.pos.split('-'), item.pos.split('-'))) {\n            haveParent = true;\n\n            if (!ii.children) {\n              ii.children = [];\n            }\n\n            ii.children.push(item);\n          }\n        });\n\n        if (!haveParent) {\n          hierarchyNodes.push(item);\n        }\n      });\n    }\n\n    return cur;\n  }); // console.log(Date.now() - s);\n\n  return levelObj[levelArr[levelArr.length - 1]].concat(hierarchyNodes);\n} // arr.length === 628, use time: ~20ms\n\nexport function filterParentPosition(arr) {\n  var levelObj = {};\n  arr.forEach(function (item) {\n    var posLen = item.split('-').length;\n\n    if (!levelObj[posLen]) {\n      levelObj[posLen] = [];\n    }\n\n    levelObj[posLen].push(item);\n  });\n  var levelArr = Object.keys(levelObj).sort();\n\n  var _loop = function _loop(i) {\n    if (levelArr[i + 1]) {\n      levelObj[levelArr[i]].forEach(function (ii) {\n        var _loop2 = function _loop2(j) {\n          levelObj[levelArr[j]].forEach(function (_i, index) {\n            if (isInclude(ii.split('-'), _i.split('-'))) {\n              levelObj[levelArr[j]][index] = null;\n            }\n          });\n          levelObj[levelArr[j]] = levelObj[levelArr[j]].filter(function (p) {\n            return p;\n          });\n        };\n\n        for (var j = i + 1; j < levelArr.length; j++) {\n          _loop2(j);\n        }\n      });\n    }\n  };\n\n  for (var i = 0; i < levelArr.length; i++) {\n    _loop(i);\n  }\n\n  var nArr = [];\n  levelArr.forEach(function (i) {\n    nArr = nArr.concat(levelObj[i]);\n  });\n  return nArr;\n} // console.log(filterParentPosition(\n// ['0-2', '0-3-3', '0-10', '0-10-0', '0-0-1', '0-0', '0-1-1', '0-1']\n// ));\n\nfunction stripTail(str) {\n  var arr = str.match(/(.+)(-[^-]+)$/);\n  var st = '';\n\n  if (arr && arr.length === 3) {\n    st = arr[1];\n  }\n\n  return st;\n}\n\nfunction splitPosition(pos) {\n  return pos.split('-');\n} // todo: do optimization.\n\n\nexport function handleCheckState(obj, checkedPositionArr, checkIt) {\n  // console.log(stripTail('0-101-000'));\n  // let s = Date.now();\n  var objKeys = Object.keys(obj);\n  objKeys.forEach(function (i, index) {\n    var iArr = splitPosition(i);\n    var saved = false;\n    checkedPositionArr.forEach(function (_pos) {\n      var _posArr = splitPosition(_pos);\n\n      if (iArr.length > _posArr.length && isInclude(_posArr, iArr)) {\n        obj[i].halfChecked = false;\n        obj[i].checked = checkIt;\n        objKeys[index] = null;\n      }\n\n      if (iArr[0] === _posArr[0] && iArr[1] === _posArr[1]) {\n        saved = true;\n      }\n    });\n\n    if (!saved) {\n      objKeys[index] = null;\n    }\n  });\n  objKeys = objKeys.filter(function (i) {\n    return i;\n  }); // filter non null;\n\n  var _loop3 = function _loop3(_pIndex) {\n    // loop to set ancestral nodes's `checked` or `halfChecked`\n    var loop = function loop(__pos) {\n      var _posLen = splitPosition(__pos).length;\n\n      if (_posLen <= 2) {\n        // e.g. '0-0', '0-1'\n        return;\n      }\n\n      var sibling = 0;\n      var siblingChecked = 0;\n      var parentPosition = stripTail(__pos);\n      objKeys.forEach(function (i\n      /* , index*/\n      ) {\n        var iArr = splitPosition(i);\n\n        if (iArr.length === _posLen && isInclude(splitPosition(parentPosition), iArr)) {\n          sibling++;\n\n          if (obj[i].checked) {\n            siblingChecked++;\n\n            var _i = checkedPositionArr.indexOf(i);\n\n            if (_i > -1) {\n              checkedPositionArr.splice(_i, 1);\n\n              if (_i <= _pIndex) {\n                _pIndex--;\n              }\n            }\n          } else if (obj[i].halfChecked) {\n            siblingChecked += 0.5;\n          } // objKeys[index] = null;\n\n        }\n      }); // objKeys = objKeys.filter(i => i); // filter non null;\n\n      var parent = obj[parentPosition]; // not check, checked, halfChecked\n\n      if (siblingChecked === 0) {\n        parent.checked = false;\n        parent.halfChecked = false;\n      } else if (siblingChecked === sibling) {\n        parent.checked = true;\n        parent.halfChecked = false;\n      } else {\n        parent.halfChecked = true;\n        parent.checked = false;\n      }\n\n      loop(parentPosition);\n    };\n\n    loop(checkedPositionArr[_pIndex], _pIndex);\n    pIndex = _pIndex;\n  };\n\n  for (var pIndex = 0; pIndex < checkedPositionArr.length; pIndex++) {\n    _loop3(pIndex);\n  } // console.log(Date.now()-s, objKeys.length, checkIt);\n\n}\n\nfunction getCheck(treeNodesStates, checkedPositions) {\n  var halfCheckedKeys = [];\n  var checkedKeys = [];\n  var checkedNodes = [];\n  Object.keys(treeNodesStates).forEach(function (item) {\n    var itemObj = treeNodesStates[item];\n\n    if (itemObj.checked) {\n      checkedKeys.push(itemObj.key); // checkedNodes.push(getValuePropValue(itemObj.node));\n\n      checkedNodes.push(_extends({}, itemObj, {\n        pos: item\n      }));\n    } else if (itemObj.halfChecked) {\n      halfCheckedKeys.push(itemObj.key);\n    }\n  });\n  return {\n    halfCheckedKeys: halfCheckedKeys,\n    checkedKeys: checkedKeys,\n    checkedNodes: checkedNodes,\n    treeNodesStates: treeNodesStates,\n    checkedPositions: checkedPositions\n  };\n}\n\nexport function getTreeNodesStates(children, values) {\n  var checkedPositions = [];\n  var treeNodesStates = {};\n  loopAllChildren(children, function (item, index, pos, keyOrPos, siblingPosition) {\n    treeNodesStates[pos] = {\n      node: item,\n      key: keyOrPos,\n      checked: false,\n      halfChecked: false,\n      siblingPosition: siblingPosition\n    };\n\n    if (values.indexOf(getValuePropValue(item)) !== -1) {\n      treeNodesStates[pos].checked = true;\n      checkedPositions.push(pos);\n    }\n  });\n  handleCheckState(treeNodesStates, filterParentPosition(checkedPositions.sort()), true);\n  return getCheck(treeNodesStates, checkedPositions);\n} // can add extra prop to every node.\n\nexport function recursiveCloneChildren(children) {\n  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (ch) {\n    return ch;\n  }; // return React.Children.map(children, child => {\n\n  return Array.from(children).map(function (child) {\n    var newChild = cb(child);\n\n    if (newChild && newChild.props && newChild.props.children) {\n      return React.cloneElement(newChild, {}, recursiveCloneChildren(newChild.props.children, cb));\n    }\n\n    return newChild;\n  });\n} // const newChildren = recursiveCloneChildren(children, child => {\n//   const extraProps = {};\n//   if (child && child.type && child.type.xxx) {\n//     extraProps._prop = true;\n//     return React.cloneElement(child, extraProps);\n//   }\n//   return child;\n// });\n\nfunction recursiveGen(children) {\n  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return React.Children.map(children, function (child, index) {\n    var pos = level + '-' + index;\n    var o = {\n      title: child.props.title,\n      label: child.props.label || child.props.title,\n      value: child.props.value,\n      key: child.key,\n      _pos: pos\n    };\n\n    if (child.props.children) {\n      o.children = recursiveGen(child.props.children, pos);\n    }\n\n    return o;\n  });\n}\n\nfunction recursive(children, cb) {\n  children.forEach(function (item) {\n    cb(item);\n\n    if (item.children) {\n      recursive(item.children, cb);\n    }\n  });\n} // Get the tree's checkedNodes (todo: can merge to the `handleCheckState` function)\n// If one node checked, it's all children nodes checked.\n// If sibling nodes all checked, the parent checked.\n\n\nexport function filterAllCheckedData(vs, treeNodes) {\n  var vals = [].concat(vs);\n\n  if (!vals.length) {\n    return vals;\n  }\n\n  var data = recursiveGen(treeNodes);\n  var checkedNodesPositions = [];\n\n  function checkChildren(children) {\n    children.forEach(function (item) {\n      if (item.__checked) {\n        return;\n      }\n\n      var ci = vals.indexOf(item.value);\n      var childs = item.children;\n\n      if (ci > -1) {\n        item.__checked = true;\n        checkedNodesPositions.push({\n          node: item,\n          pos: item._pos\n        });\n        vals.splice(ci, 1);\n\n        if (childs) {\n          recursive(childs, function (child) {\n            child.__checked = true;\n            checkedNodesPositions.push({\n              node: child,\n              pos: child._pos\n            });\n          });\n        }\n      } else {\n        if (childs) {\n          checkChildren(childs);\n        }\n      }\n    });\n  }\n\n  function checkParent(children) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      root: true\n    };\n    var siblingChecked = 0;\n    children.forEach(function (item) {\n      var childs = item.children;\n\n      if (childs && !item.__checked && !item.__halfChecked) {\n        var p = checkParent(childs, item);\n\n        if (p.__checked) {\n          siblingChecked++;\n        } else if (p.__halfChecked) {\n          siblingChecked += 0.5;\n        }\n      } else if (item.__checked) {\n        siblingChecked++;\n      } else if (item.__halfChecked) {\n        siblingChecked += 0.5;\n      }\n    });\n    var len = children.length;\n\n    if (siblingChecked === len) {\n      parent.__checked = true;\n      checkedNodesPositions.push({\n        node: parent,\n        pos: parent._pos\n      });\n    } else if (siblingChecked < len && siblingChecked > 0) {\n      parent.__halfChecked = true;\n    }\n\n    if (parent.root) {\n      return children;\n    }\n\n    return parent;\n  }\n\n  checkChildren(data);\n  checkParent(data);\n  checkedNodesPositions.forEach(function (i, index) {\n    // clear private metadata\n    delete checkedNodesPositions[index].node.__checked;\n    delete checkedNodesPositions[index].node._pos; // create the same structure of `onCheck`'s return.\n\n    checkedNodesPositions[index].node.props = {\n      title: checkedNodesPositions[index].node.title,\n      label: checkedNodesPositions[index].node.label || checkedNodesPositions[index].node.title,\n      value: checkedNodesPositions[index].node.value\n    };\n\n    if (checkedNodesPositions[index].node.children) {\n      checkedNodesPositions[index].node.props.children = checkedNodesPositions[index].node.children;\n    }\n\n    delete checkedNodesPositions[index].node.title;\n    delete checkedNodesPositions[index].node.label;\n    delete checkedNodesPositions[index].node.value;\n    delete checkedNodesPositions[index].node.children;\n  });\n  return checkedNodesPositions;\n}\nexport function processSimpleTreeData(treeData, format) {\n  function unflatten2(array) {\n    var _ref;\n\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_ref = {}, _ref[format.id] = format.rootPId, _ref);\n    var children = [];\n\n    for (var i = 0; i < array.length; i++) {\n      array[i] = _extends({}, array[i]); // copy, can not corrupts original data\n\n      if (array[i][format.pId] === parent[format.id]) {\n        array[i].key = array[i][format.id];\n        children.push(array[i]);\n        array.splice(i--, 1);\n      }\n    }\n\n    if (children.length) {\n      parent.children = children;\n      children.forEach(function (child) {\n        return unflatten2(array, child);\n      });\n    }\n\n    if (parent[format.id] === format.rootPId) {\n      return children;\n    }\n  }\n\n  return unflatten2(treeData);\n}","map":null,"metadata":{},"sourceType":"module"}