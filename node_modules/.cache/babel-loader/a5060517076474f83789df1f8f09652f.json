{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // inspired by react-native\n\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport PressEvent, { shouldFirePress } from './PressEvent';\n\nfunction keyMirror(obj) {\n  Object.keys(obj).forEach(function (k) {\n    return obj[k] = k;\n  });\n  return obj;\n}\n\nfunction copy(from, list) {\n  var to = {};\n  list.forEach(function (k) {\n    to[k] = from[k];\n  });\n  return to;\n}\n\nfunction extractSingleTouch(_nativeEvent) {\n  var nativeEvent = _nativeEvent;\n\n  if (nativeEvent.nativeEvent) {\n    nativeEvent = nativeEvent.nativeEvent;\n  }\n\n  var touches = nativeEvent.touches;\n  var changedTouches = nativeEvent.changedTouches;\n  var hasTouches = touches && touches.length > 0;\n  var hasChangedTouches = changedTouches && changedTouches.length > 0;\n  return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;\n}\n/**\n * Touchable states.\n */\n\n\nvar States = keyMirror({\n  NOT_RESPONDER: null,\n  RESPONDER_INACTIVE_PRESS_IN: null,\n  RESPONDER_INACTIVE_PRESS_OUT: null,\n  RESPONDER_ACTIVE_PRESS_IN: null,\n  RESPONDER_ACTIVE_PRESS_OUT: null,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: null,\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: null,\n  ERROR: null\n});\n/**\n * Quick lookup map for states that are considered to be \"active\"\n */\n\nvar IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\n\nvar IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\nvar IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\n/**\n * Inputs to the state machine.\n */\n\nvar Signals = keyMirror({\n  DELAY: null,\n  RESPONDER_GRANT: null,\n  RESPONDER_RELEASE: null,\n  RESPONDER_TERMINATED: null,\n  ENTER_PRESS_RECT: null,\n  LEAVE_PRESS_RECT: null,\n  LONG_PRESS_DETECTED: null\n});\n/**\n * Mapping from States x Signals => States\n */\n\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n}; // ==== Typical Constants for integrating into UI components ====\n// const HIT_EXPAND_PX = 20;\n// const HIT_VERT_OFFSET_PX = 10;\n\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\nvar lastClickTime = 0;\nvar pressDelay = 200;\n\nfunction isAllowPress() {\n  // avoid click penetration\n  return Date.now() - lastClickTime >= pressDelay;\n}\n\nvar Touchable = function (_React$Component) {\n  _inherits(Touchable, _React$Component);\n\n  function Touchable() {\n    _classCallCheck(this, Touchable);\n\n    var _this = _possibleConstructorReturn(this, (Touchable.__proto__ || Object.getPrototypeOf(Touchable)).apply(this, arguments));\n\n    _this.state = {\n      active: false\n    };\n    _this.touchable = {\n      touchState: undefined\n    };\n\n    _this.onTouchStart = function (e) {\n      _this.callChildEvent('onTouchStart', e);\n\n      _this.lockMouse = true;\n\n      if (_this.releaseLockTimer) {\n        clearTimeout(_this.releaseLockTimer);\n      }\n\n      _this.touchableHandleResponderGrant(e.nativeEvent);\n    };\n\n    _this.onTouchMove = function (e) {\n      _this.callChildEvent('onTouchMove', e);\n\n      _this.touchableHandleResponderMove(e.nativeEvent);\n    };\n\n    _this.onTouchEnd = function (e) {\n      _this.callChildEvent('onTouchEnd', e);\n\n      _this.releaseLockTimer = setTimeout(function () {\n        _this.lockMouse = false;\n      }, 300);\n\n      _this.touchableHandleResponderRelease(new PressEvent(e.nativeEvent));\n    };\n\n    _this.onTouchCancel = function (e) {\n      _this.callChildEvent('onTouchCancel', e);\n\n      _this.releaseLockTimer = setTimeout(function () {\n        _this.lockMouse = false;\n      }, 300);\n\n      _this.touchableHandleResponderTerminate(e.nativeEvent);\n    };\n\n    _this.onMouseDown = function (e) {\n      _this.callChildEvent('onMouseDown', e);\n\n      if (_this.lockMouse) {\n        return;\n      }\n\n      _this.touchableHandleResponderGrant(e.nativeEvent);\n\n      document.addEventListener('mousemove', _this.touchableHandleResponderMove, false);\n      document.addEventListener('mouseup', _this.onMouseUp, false);\n    };\n\n    _this.onMouseUp = function (e) {\n      document.removeEventListener('mousemove', _this.touchableHandleResponderMove, false);\n      document.removeEventListener('mouseup', _this.onMouseUp, false);\n\n      _this.touchableHandleResponderRelease(new PressEvent(e));\n    };\n\n    _this.touchableHandleResponderMove = function (e) {\n      if (!_this.touchable.startMouse) {\n        return;\n      } // Measurement may not have returned yet.\n\n\n      if (!_this.touchable.dimensionsOnActivate || _this.touchable.touchState === States.NOT_RESPONDER) {\n        return;\n      } // Not enough time elapsed yet, wait for highlight -\n      // this is just a perf optimization.\n\n\n      if (_this.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n        return;\n      }\n\n      var touch = extractSingleTouch(e);\n      var pageX = touch && touch.pageX;\n      var pageY = touch && touch.pageY;\n\n      if (_this.pressInLocation) {\n        var movedDistance = _this._getDistanceBetweenPoints(pageX, pageY, _this.pressInLocation.pageX, _this.pressInLocation.pageY);\n\n        if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n          _this._cancelLongPressDelayTimeout();\n        }\n      }\n\n      if (_this.checkTouchWithinActive(e)) {\n        _this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n\n        var curState = _this.touchable.touchState;\n\n        if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n          _this._cancelLongPressDelayTimeout();\n        }\n      } else {\n        _this._cancelLongPressDelayTimeout();\n\n        _this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(Touchable, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.root = ReactDOM.findDOMNode(this);\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.root = ReactDOM.findDOMNode(this); // disabled auto clear active state\n\n      if (this.props.disabled && this.state.active) {\n        this.setState({\n          active: false\n        });\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.releaseLockTimer) {\n        clearTimeout(this.releaseLockTimer);\n      }\n\n      if (this.touchableDelayTimeout) {\n        clearTimeout(this.touchableDelayTimeout);\n      }\n\n      if (this.longPressDelayTimeout) {\n        clearTimeout(this.longPressDelayTimeout);\n      }\n\n      if (this.pressOutDelayTimeout) {\n        clearTimeout(this.pressOutDelayTimeout);\n      }\n    }\n  }, {\n    key: 'callChildEvent',\n    value: function callChildEvent(event, e) {\n      var childHandle = React.Children.only(this.props.children).props[event];\n\n      if (childHandle) {\n        childHandle(e);\n      }\n    }\n  }, {\n    key: '_remeasureMetricsOnInit',\n    value: function _remeasureMetricsOnInit(e) {\n      var root = this.root;\n      var touch = extractSingleTouch(e);\n      var boundingRect = root.getBoundingClientRect();\n      this.touchable = {\n        touchState: this.touchable.touchState,\n        startMouse: {\n          pageX: touch.pageX,\n          pageY: touch.pageY\n        },\n        positionOnGrant: {\n          left: boundingRect.left + window.pageXOffset,\n          top: boundingRect.top + window.pageYOffset,\n          width: boundingRect.width,\n          height: boundingRect.height,\n          clientLeft: boundingRect.left,\n          clientTop: boundingRect.top\n        }\n      };\n    }\n  }, {\n    key: 'processActiveStopPropagation',\n    value: function processActiveStopPropagation(e) {\n      var nativeEvent = e.nativeEvent || e;\n      this.shouldActive = !nativeEvent.__activeStopPropagation;\n\n      if (this.props.activeStopPropagation) {\n        nativeEvent.__activeStopPropagation = 1;\n      }\n    }\n  }, {\n    key: 'touchableHandleResponderGrant',\n    value: function touchableHandleResponderGrant(e) {\n      var _this2 = this;\n\n      this.touchable.touchState = States.NOT_RESPONDER;\n\n      if (this.pressOutDelayTimeout) {\n        clearTimeout(this.pressOutDelayTimeout);\n        this.pressOutDelayTimeout = null;\n      }\n\n      if (this.props.fixClickPenetration && !isAllowPress()) {\n        return;\n      }\n\n      this._remeasureMetricsOnInit(e);\n\n      this._receiveSignal(Signals.RESPONDER_GRANT, e);\n\n      var _props = this.props,\n          delayMS = _props.delayPressIn,\n          longDelayMS = _props.delayLongPress;\n      this.processActiveStopPropagation(e);\n\n      if (delayMS) {\n        this.touchableDelayTimeout = setTimeout(function () {\n          _this2._handleDelay(e);\n        }, delayMS);\n      } else {\n        this._handleDelay(e);\n      }\n\n      var longPressEvent = new PressEvent(e);\n      this.longPressDelayTimeout = setTimeout(function () {\n        _this2._handleLongDelay(longPressEvent);\n      }, longDelayMS + delayMS);\n    }\n  }, {\n    key: 'checkScroll',\n    value: function checkScroll(e) {\n      var positionOnGrant = this.touchable.positionOnGrant; // container or window scroll\n\n      var boundingRect = this.root.getBoundingClientRect();\n\n      if (boundingRect.left !== positionOnGrant.clientLeft || boundingRect.top !== positionOnGrant.clientTop) {\n        this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'touchableHandleResponderRelease',\n    value: function touchableHandleResponderRelease(e) {\n      if (!this.touchable.startMouse) {\n        return;\n      }\n\n      var touch = extractSingleTouch(e);\n\n      if (Math.abs(touch.pageX - this.touchable.startMouse.pageX) > 30 || Math.abs(touch.pageY - this.touchable.startMouse.pageY) > 30) {\n        this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n\n        return;\n      }\n\n      if (this.checkScroll(e)) {\n        return;\n      }\n\n      this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n    }\n  }, {\n    key: 'touchableHandleResponderTerminate',\n    value: function touchableHandleResponderTerminate(e) {\n      if (!this.touchable.startMouse) {\n        return;\n      }\n\n      this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n    }\n  }, {\n    key: 'checkTouchWithinActive',\n    value: function checkTouchWithinActive(e) {\n      var positionOnGrant = this.touchable.positionOnGrant;\n      var _props2 = this.props,\n          _props2$pressRetentio = _props2.pressRetentionOffset,\n          pressRetentionOffset = _props2$pressRetentio === undefined ? {} : _props2$pressRetentio,\n          hitSlop = _props2.hitSlop;\n      var pressExpandLeft = pressRetentionOffset.left;\n      var pressExpandTop = pressRetentionOffset.top;\n      var pressExpandRight = pressRetentionOffset.right;\n      var pressExpandBottom = pressRetentionOffset.bottom;\n\n      if (hitSlop) {\n        pressExpandLeft += hitSlop.left;\n        pressExpandTop += hitSlop.top;\n        pressExpandRight += hitSlop.right;\n        pressExpandBottom += hitSlop.bottom;\n      }\n\n      var touch = extractSingleTouch(e);\n      var pageX = touch && touch.pageX;\n      var pageY = touch && touch.pageY;\n      return pageX > positionOnGrant.left - pressExpandLeft && pageY > positionOnGrant.top - pressExpandTop && pageX < positionOnGrant.left + positionOnGrant.width + pressExpandRight && pageY < positionOnGrant.top + positionOnGrant.height + pressExpandBottom;\n    }\n  }, {\n    key: 'callProp',\n    value: function callProp(name, e) {\n      if (this.props[name] && !this.props.disabled) {\n        this.props[name](e);\n      }\n    }\n  }, {\n    key: 'touchableHandleActivePressIn',\n    value: function touchableHandleActivePressIn(e) {\n      if (this.shouldActive) {\n        this.setActive(true);\n      }\n\n      this.callProp('onPressIn', e);\n    }\n  }, {\n    key: 'touchableHandleActivePressOut',\n    value: function touchableHandleActivePressOut(e) {\n      this.setActive(false);\n      this.callProp('onPressOut', e);\n    }\n  }, {\n    key: 'touchableHandlePress',\n    value: function touchableHandlePress(e) {\n      if (shouldFirePress(e)) {\n        this.callProp('onPress', e);\n      }\n\n      lastClickTime = Date.now();\n    }\n  }, {\n    key: 'touchableHandleLongPress',\n    value: function touchableHandleLongPress(e) {\n      if (shouldFirePress(e)) {\n        this.callProp('onLongPress', e);\n      }\n    }\n  }, {\n    key: 'setActive',\n    value: function setActive(active) {\n      if (this.state.active !== active && (this.props.activeClassName || this.props.activeStyle)) {\n        this.setState({\n          active: active\n        });\n      }\n    }\n  }, {\n    key: '_remeasureMetricsOnActivation',\n    value: function _remeasureMetricsOnActivation() {\n      this.touchable.dimensionsOnActivate = this.touchable.positionOnGrant;\n    }\n  }, {\n    key: '_handleDelay',\n    value: function _handleDelay(e) {\n      this.touchableDelayTimeout = null;\n\n      this._receiveSignal(Signals.DELAY, e);\n    }\n  }, {\n    key: '_handleLongDelay',\n    value: function _handleLongDelay(e) {\n      this.longPressDelayTimeout = null;\n      var curState = this.touchable.touchState;\n\n      if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n        console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n      } else {\n        this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n      }\n    }\n  }, {\n    key: '_receiveSignal',\n    value: function _receiveSignal(signal, e) {\n      var curState = this.touchable.touchState;\n      var nextState = Transitions[curState] && Transitions[curState][signal];\n\n      if (!nextState) {\n        return;\n      }\n\n      if (nextState === States.ERROR) {\n        return;\n      }\n\n      if (curState !== nextState) {\n        this._performSideEffectsForTransition(curState, nextState, signal, e);\n\n        this.touchable.touchState = nextState;\n      }\n    }\n  }, {\n    key: '_cancelLongPressDelayTimeout',\n    value: function _cancelLongPressDelayTimeout() {\n      if (this.longPressDelayTimeout) {\n        clearTimeout(this.longPressDelayTimeout);\n        this.longPressDelayTimeout = null;\n      }\n    }\n  }, {\n    key: '_isHighlight',\n    value: function _isHighlight(state) {\n      return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n    }\n  }, {\n    key: '_savePressInLocation',\n    value: function _savePressInLocation(e) {\n      var touch = extractSingleTouch(e);\n      var pageX = touch && touch.pageX;\n      var pageY = touch && touch.pageY;\n      this.pressInLocation = {\n        pageX: pageX,\n        pageY: pageY\n      };\n    }\n  }, {\n    key: '_getDistanceBetweenPoints',\n    value: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n      var deltaX = aX - bX;\n      var deltaY = aY - bY;\n      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    }\n  }, {\n    key: '_performSideEffectsForTransition',\n    value: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n      var curIsHighlight = this._isHighlight(curState);\n\n      var newIsHighlight = this._isHighlight(nextState);\n\n      var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n      if (isFinalSignal) {\n        this._cancelLongPressDelayTimeout();\n      }\n\n      if (!IsActive[curState] && IsActive[nextState]) {\n        this._remeasureMetricsOnActivation();\n      }\n\n      if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n        this.touchableHandleLongPress(e);\n      }\n\n      if (newIsHighlight && !curIsHighlight) {\n        this._startHighlight(e);\n      } else if (!newIsHighlight && curIsHighlight) {\n        this._endHighlight(e);\n      }\n\n      if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n        var hasLongPressHandler = !!this.props.onLongPress;\n        var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing..\n        !hasLongPressHandler || // But either has no long handler\n        !this.props.longPressCancelsPress // or we're told to ignore it.\n        );\n        var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n\n        if (shouldInvokePress) {\n          if (!newIsHighlight && !curIsHighlight) {\n            // we never highlighted because of delay, but we should highlight now\n            this._startHighlight(e);\n\n            this._endHighlight(e);\n          }\n\n          this.touchableHandlePress(e);\n        }\n      }\n\n      if (this.touchableDelayTimeout) {\n        clearTimeout(this.touchableDelayTimeout);\n        this.touchableDelayTimeout = null;\n      }\n    }\n  }, {\n    key: '_startHighlight',\n    value: function _startHighlight(e) {\n      this._savePressInLocation(e);\n\n      this.touchableHandleActivePressIn(e);\n    }\n  }, {\n    key: '_endHighlight',\n    value: function _endHighlight(e) {\n      var _this3 = this;\n\n      if (this.props.delayPressOut) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this3.touchableHandleActivePressOut(e);\n        }, this.props.delayPressOut);\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          children = _props3.children,\n          disabled = _props3.disabled,\n          activeStyle = _props3.activeStyle,\n          activeClassName = _props3.activeClassName;\n      var events = disabled ? undefined : copy(this, ['onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel', 'onMouseDown']);\n      var child = React.Children.only(children);\n\n      if (!disabled && this.state.active) {\n        var _child$props = child.props,\n            style = _child$props.style,\n            className = _child$props.className;\n\n        if (activeStyle) {\n          style = _extends({}, style, activeStyle);\n        }\n\n        if (activeClassName) {\n          if (className) {\n            className += ' ' + activeClassName;\n          } else {\n            className = activeClassName;\n          }\n        }\n\n        return React.cloneElement(child, _extends({\n          className: className,\n          style: style\n        }, events));\n      }\n\n      return React.cloneElement(child, events);\n    }\n  }]);\n\n  return Touchable;\n}(React.Component);\n\nexport default Touchable;\nTouchable.defaultProps = {\n  fixClickPenetration: false,\n  disabled: false,\n  delayPressIn: HIGHLIGHT_DELAY_MS,\n  delayLongPress: LONG_PRESS_DELAY_MS,\n  delayPressOut: 100,\n  pressRetentionOffset: {\n    left: PRESS_EXPAND_PX,\n    right: PRESS_EXPAND_PX,\n    top: PRESS_EXPAND_PX,\n    bottom: PRESS_EXPAND_PX\n  },\n  hitSlop: undefined,\n  longPressCancelsPress: true\n};","map":null,"metadata":{},"sourceType":"module"}