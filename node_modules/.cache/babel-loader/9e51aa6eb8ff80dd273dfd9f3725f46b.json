{"ast":null,"code":"import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport KeyCode from 'rc-util/es/KeyCode';\nimport classnames from 'classnames';\nimport assign from 'object-assign';\nimport Animate from 'rc-animate';\nimport { getPropValue, getValuePropValue\n/* isCombobox,*/\n, isMultipleOrTags, isMultipleOrTagsOrCombobox, isSingleMode, toArray, UNSELECTABLE_ATTRIBUTE, UNSELECTABLE_STYLE, preventDefaultEvent, getTreeNodesStates, flatToHierarchy, filterParentPosition, isInclude, labelCompatible, loopAllChildren, filterAllCheckedData, processSimpleTreeData } from './util';\nimport SelectTrigger from './SelectTrigger';\nimport _TreeNode from './TreeNode';\nimport { SHOW_ALL, SHOW_PARENT, SHOW_CHILD } from './strategies';\nimport { SelectPropTypes } from './PropTypes';\n\nfunction noop() {}\n\nfunction filterFn(input, child) {\n  return String(getPropValue(child, labelCompatible(this.props.treeNodeFilterProp))).indexOf(input) > -1;\n}\n\nfunction saveRef(name, component) {\n  this[name] = component;\n}\n\nfunction loopTreeData(data) {\n  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return data.map(function (item, index) {\n    var pos = level + '-' + index;\n\n    var label = item.label,\n        value = item.value,\n        disabled = item.disabled,\n        key = item.key,\n        hasOwnProperty = item.hasOwnProperty,\n        selectable = item.selectable,\n        children = item.children,\n        isLeaf = item.isLeaf,\n        otherProps = _objectWithoutProperties(item, ['label', 'value', 'disabled', 'key', 'hasOwnProperty', 'selectable', 'children', 'isLeaf']);\n\n    var props = _extends({\n      value: value,\n      title: label,\n      // value: value || String(key || label), // cause onChange callback error\n      key: key || value || pos,\n      disabled: disabled || false,\n      selectable: selectable === false ? selectable : true\n    }, otherProps);\n\n    var ret = void 0;\n\n    if (children && children.length) {\n      ret = React.createElement(_TreeNode, props, loopTreeData(children, pos));\n    } else {\n      ret = React.createElement(_TreeNode, _extends({}, props, {\n        isLeaf: isLeaf\n      }));\n    }\n\n    return ret;\n  });\n}\n\nvar Select = function (_Component) {\n  _inherits(Select, _Component);\n\n  function Select(props) {\n    _classCallCheck(this, Select);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var value = [];\n\n    if ('value' in props) {\n      value = toArray(props.value);\n    } else {\n      value = toArray(props.defaultValue);\n    } // save parsed treeData, for performance (treeData may be very big)\n\n\n    _this.renderedTreeData = _this.renderTreeData();\n    value = _this.addLabelToValue(props, value);\n    value = _this.getValue(props, value, props.inputValue ? '__strict' : true);\n    var inputValue = props.inputValue || ''; // if (props.combobox) {\n    //   inputValue = value.length ? String(value[0].value) : '';\n    // }\n\n    _this.saveInputRef = saveRef.bind(_this, 'inputInstance');\n    _this.saveInputMirrorRef = saveRef.bind(_this, 'inputMirrorInstance');\n    _this.state = {\n      value: value,\n      inputValue: inputValue,\n      open: props.open || props.defaultOpen,\n      focused: false\n    };\n    return _this;\n  }\n\n  Select.prototype.componentDidMount = function componentDidMount() {\n    if (isMultipleOrTags(this.props)) {\n      var inputNode = this.getInputDOMNode();\n\n      if (inputNode.value) {\n        inputNode.style.width = '';\n        inputNode.style.width = this.inputMirrorInstance.clientWidth + 'px';\n      } else {\n        inputNode.style.width = '';\n      }\n    }\n  };\n\n  Select.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    // save parsed treeData, for performance (treeData may be very big)\n    this.renderedTreeData = this.renderTreeData(nextProps); // Detecting whether the object of `onChange`'s argument  is old ref.\n    // Better to do a deep equal later.\n\n    this._cacheTreeNodesStates = this._cacheTreeNodesStates !== 'no' && this._savedValue && nextProps.value === this._savedValue;\n\n    if (this.props.treeData !== nextProps.treeData || this.props.children !== nextProps.children) {\n      // refresh this._treeNodesStates cache\n      this._treeNodesStates = getTreeNodesStates(this.renderedTreeData || nextProps.children, this.state.value.map(function (item) {\n        return item.value;\n      }));\n    }\n\n    if ('value' in nextProps) {\n      var value = toArray(nextProps.value);\n      value = this.addLabelToValue(nextProps, value);\n      value = this.getValue(nextProps, value);\n      this.setState({\n        value: value\n      }); // if (nextProps.combobox) {\n      //   this.setState({\n      //     inputValue: value.length ? String(value[0].key) : '',\n      //   });\n      // }\n    }\n\n    if (nextProps.inputValue !== this.props.inputValue) {\n      this.setState({\n        inputValue: nextProps.inputValue\n      });\n    }\n\n    if ('open' in nextProps) {\n      this.setState({\n        open: nextProps.open\n      });\n    }\n  };\n\n  Select.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {\n    if (this._savedValue && nextProps.value && nextProps.value !== this._savedValue && nextProps.value === this.props.value) {\n      this._cacheTreeNodesStates = false;\n      this.getValue(nextProps, this.addLabelToValue(nextProps, toArray(nextProps.value)));\n    }\n  };\n\n  Select.prototype.componentDidUpdate = function componentDidUpdate() {\n    var state = this.state;\n    var props = this.props;\n\n    if (state.open && isMultipleOrTags(props)) {\n      var inputNode = this.getInputDOMNode();\n\n      if (inputNode.value) {\n        inputNode.style.width = '';\n        inputNode.style.width = this.inputMirrorInstance.clientWidth + 'px';\n      } else {\n        inputNode.style.width = '';\n      }\n    }\n  };\n\n  Select.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.clearDelayTimer();\n\n    if (this.dropdownContainer) {\n      ReactDOM.unmountComponentAtNode(this.dropdownContainer);\n      document.body.removeChild(this.dropdownContainer);\n      this.dropdownContainer = null;\n    }\n  }; // combobox ignore\n\n\n  Select.prototype.getLabelFromNode = function getLabelFromNode(child) {\n    return getPropValue(child, this.props.treeNodeLabelProp);\n  };\n\n  Select.prototype.getLabelFromProps = function getLabelFromProps(props, value) {\n    var _this2 = this;\n\n    if (value === undefined) {\n      return null;\n    }\n\n    var label = null;\n    loopAllChildren(this.renderedTreeData || props.children, function (item) {\n      if (getValuePropValue(item) === value) {\n        label = _this2.getLabelFromNode(item);\n      }\n    });\n\n    if (label === null) {\n      return value;\n    }\n\n    return label;\n  };\n\n  Select.prototype.getDropdownContainer = function getDropdownContainer() {\n    if (!this.dropdownContainer) {\n      this.dropdownContainer = document.createElement('div');\n      document.body.appendChild(this.dropdownContainer);\n    }\n\n    return this.dropdownContainer;\n  };\n\n  Select.prototype.getSearchPlaceholderElement = function getSearchPlaceholderElement(hidden) {\n    var props = this.props;\n    var placeholder = void 0;\n\n    if (isMultipleOrTagsOrCombobox(props)) {\n      placeholder = props.placeholder || props.searchPlaceholder;\n    } else {\n      placeholder = props.searchPlaceholder;\n    }\n\n    if (placeholder) {\n      return React.createElement('span', {\n        style: {\n          display: hidden ? 'none' : 'block'\n        },\n        onClick: this.onPlaceholderClick,\n        className: props.prefixCls + '-search__field__placeholder'\n      }, placeholder);\n    }\n\n    return null;\n  };\n\n  Select.prototype.getInputElement = function getInputElement() {\n    var inputValue = this.state.inputValue;\n    var _props2 = this.props,\n        prefixCls = _props2.prefixCls,\n        disabled = _props2.disabled;\n    return React.createElement('span', {\n      className: prefixCls + '-search__field__wrap'\n    }, React.createElement('input', {\n      ref: this.saveInputRef,\n      onChange: this.onInputChange,\n      onKeyDown: this.onInputKeyDown,\n      value: inputValue,\n      disabled: disabled,\n      className: prefixCls + '-search__field',\n      role: 'textbox'\n    }), React.createElement('span', {\n      ref: this.saveInputMirrorRef,\n      className: prefixCls + '-search__field__mirror'\n    }, inputValue, '\\xA0'), isMultipleOrTags(this.props) ? null : this.getSearchPlaceholderElement(!!inputValue));\n  };\n\n  Select.prototype.getInputDOMNode = function getInputDOMNode() {\n    return this.inputInstance;\n  };\n\n  Select.prototype.getPopupDOMNode = function getPopupDOMNode() {\n    return this.refs.trigger.getPopupDOMNode();\n  };\n\n  Select.prototype.getPopupComponentRefs = function getPopupComponentRefs() {\n    return this.refs.trigger.getPopupEleRefs();\n  };\n\n  Select.prototype.getValue = function getValue(_props, val) {\n    var _this3 = this;\n\n    var init = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var value = val; // if inputValue existing, tree is checkStrictly\n\n    var _strict = init === '__strict' || init && (this.state && this.state.inputValue || this.props.inputValue !== _props.inputValue);\n\n    if (_props.treeCheckable && (_props.treeCheckStrictly || _strict)) {\n      this.halfCheckedValues = [];\n      value = [];\n      val.forEach(function (i) {\n        if (!i.halfChecked) {\n          value.push(i);\n        } else {\n          _this3.halfCheckedValues.push(i);\n        }\n      });\n    } // if (!(_props.treeCheckable && !_props.treeCheckStrictly)) {\n\n\n    if (!!!_props.treeCheckable || _props.treeCheckable && (_props.treeCheckStrictly || _strict)) {\n      return value;\n    }\n\n    var checkedTreeNodes = void 0;\n\n    if (this._cachetreeData && this._cacheTreeNodesStates && this._checkedNodes && this.state && !this.state.inputValue) {\n      this.checkedTreeNodes = checkedTreeNodes = this._checkedNodes;\n    } else {\n      /**\n       * Note: `this._treeNodesStates`'s treeNodesStates must correspond to nodes of the\n       * final tree (`processTreeNode` function from SelectTrigger.jsx produce the final tree).\n       *\n       * And, `this._treeNodesStates` from `onSelect` is previous value,\n       * so it perhaps only have a few nodes, but the newly filtered tree can have many nodes,\n       * thus, you cannot use previous _treeNodesStates.\n       */\n      // getTreeNodesStates is not effective.\n      this._treeNodesStates = getTreeNodesStates(this.renderedTreeData || _props.children, value.map(function (item) {\n        return item.value;\n      }));\n      this.checkedTreeNodes = checkedTreeNodes = this._treeNodesStates.checkedNodes;\n    }\n\n    var mapLabVal = function mapLabVal(arr) {\n      return arr.map(function (itemObj) {\n        return {\n          value: getValuePropValue(itemObj.node),\n          label: getPropValue(itemObj.node, _props.treeNodeLabelProp)\n        };\n      });\n    };\n\n    var props = this.props;\n    var checkedValues = [];\n\n    if (props.showCheckedStrategy === SHOW_ALL) {\n      checkedValues = mapLabVal(checkedTreeNodes);\n    } else if (props.showCheckedStrategy === SHOW_PARENT) {\n      var posArr = filterParentPosition(checkedTreeNodes.map(function (itemObj) {\n        return itemObj.pos;\n      }));\n      checkedValues = mapLabVal(checkedTreeNodes.filter(function (itemObj) {\n        return posArr.indexOf(itemObj.pos) !== -1;\n      }));\n    } else {\n      checkedValues = mapLabVal(checkedTreeNodes.filter(function (itemObj) {\n        return !itemObj.node.props.children;\n      }));\n    }\n\n    return checkedValues;\n  };\n\n  Select.prototype.getCheckedNodes = function getCheckedNodes(info, props) {\n    // TODO treeCheckable does not support tags/dynamic\n    var checkedNodes = info.checkedNodes; // if inputValue existing, tree is checkStrictly\n\n    if (props.treeCheckStrictly || this.state.inputValue) {\n      return checkedNodes;\n    }\n\n    var checkedNodesPositions = info.checkedNodesPositions;\n\n    if (props.showCheckedStrategy === SHOW_ALL) {\n      checkedNodes = checkedNodes;\n    } else if (props.showCheckedStrategy === SHOW_PARENT) {\n      var posArr = filterParentPosition(checkedNodesPositions.map(function (itemObj) {\n        return itemObj.pos;\n      }));\n      checkedNodes = checkedNodesPositions.filter(function (itemObj) {\n        return posArr.indexOf(itemObj.pos) !== -1;\n      }).map(function (itemObj) {\n        return itemObj.node;\n      });\n    } else {\n      checkedNodes = checkedNodes.filter(function (n) {\n        return !n.props.children;\n      });\n    }\n\n    return checkedNodes;\n  };\n\n  Select.prototype.getDeselectedValue = function getDeselectedValue(selectedValue) {\n    var checkedTreeNodes = this.checkedTreeNodes;\n    var unCheckPos = void 0;\n    checkedTreeNodes.forEach(function (itemObj) {\n      if (itemObj.node.props.value === selectedValue) {\n        unCheckPos = itemObj.pos;\n      }\n    });\n    var nArr = unCheckPos && unCheckPos.split('-');\n    var newVals = [];\n    var newCkTns = [];\n    checkedTreeNodes.forEach(function (itemObj) {\n      var iArr = itemObj.pos.split('-');\n\n      if (itemObj.pos === unCheckPos || nArr.length > iArr.length && isInclude(iArr, nArr) || nArr.length < iArr.length && isInclude(nArr, iArr)) {\n        // Filter ancestral and children nodes when uncheck a node.\n        return;\n      }\n\n      newCkTns.push(itemObj);\n      newVals.push(itemObj.node.props.value);\n    });\n    this.checkedTreeNodes = this._checkedNodes = newCkTns;\n    var nv = this.state.value.filter(function (val) {\n      return newVals.indexOf(val.value) !== -1;\n    });\n    this.fireChange(nv, {\n      triggerValue: selectedValue,\n      clear: true\n    });\n  };\n\n  Select.prototype.setOpenState = function setOpenState(open, needFocus) {\n    var _this4 = this;\n\n    var documentClickClose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.clearDelayTimer();\n    var props = this.props,\n        refs = this.refs; // can not optimize, if children is empty\n    // if (this.state.open === open) {\n    //   return;\n    // }\n\n    if (!this.props.onDropdownVisibleChange(open, {\n      documentClickClose: documentClickClose\n    })) {\n      return;\n    }\n\n    this.setState({\n      open: open\n    }, function () {\n      if (needFocus || open) {\n        if (open || isMultipleOrTagsOrCombobox(props)) {\n          var input = _this4.getInputDOMNode();\n\n          if (input && document.activeElement !== input) {\n            input.focus();\n          }\n        } else if (refs.selection) {\n          refs.selection.focus();\n        }\n      }\n    });\n  };\n\n  Select.prototype.clearSearchInput = function clearSearchInput() {\n    this.getInputDOMNode().focus();\n\n    if (!('inputValue' in this.props)) {\n      this.setState({\n        inputValue: ''\n      });\n    }\n  };\n\n  Select.prototype.addLabelToValue = function addLabelToValue(props, value_) {\n    var _this5 = this;\n\n    var value = value_;\n\n    if (this.isLabelInValue()) {\n      value.forEach(function (v, i) {\n        if (Object.prototype.toString.call(value[i]) !== '[object Object]') {\n          value[i] = {\n            value: '',\n            label: ''\n          };\n          return;\n        }\n\n        v.label = v.label || _this5.getLabelFromProps(props, v.value);\n      });\n    } else {\n      value = value.map(function (v) {\n        return {\n          value: v,\n          label: _this5.getLabelFromProps(props, v)\n        };\n      });\n    }\n\n    return value;\n  };\n\n  Select.prototype.clearDelayTimer = function clearDelayTimer() {\n    if (this.delayTimer) {\n      clearTimeout(this.delayTimer);\n      this.delayTimer = null;\n    }\n  };\n\n  Select.prototype.removeSelected = function removeSelected(selectedVal) {\n    var props = this.props;\n\n    if (props.disabled) {\n      return;\n    }\n\n    this._cacheTreeNodesStates = 'no';\n\n    if (props.treeCheckable && (props.showCheckedStrategy === SHOW_ALL || props.showCheckedStrategy === SHOW_PARENT) && !(props.treeCheckStrictly || this.state.inputValue)) {\n      this.getDeselectedValue(selectedVal);\n      return;\n    } // click the node's `x`(in select box), likely trigger the TreeNode's `unCheck` event,\n    // cautiously, they are completely different, think about it, the tree may not render at first,\n    // but the nodes in select box are ready.\n\n\n    var label = void 0;\n    var value = this.state.value.filter(function (singleValue) {\n      if (singleValue.value === selectedVal) {\n        label = singleValue.label;\n      }\n\n      return singleValue.value !== selectedVal;\n    });\n    var canMultiple = isMultipleOrTags(props);\n\n    if (canMultiple) {\n      var event = selectedVal;\n\n      if (this.isLabelInValue()) {\n        event = {\n          value: selectedVal,\n          label: label\n        };\n      }\n\n      props.onDeselect(event);\n    }\n\n    if (props.treeCheckable) {\n      if (this.checkedTreeNodes && this.checkedTreeNodes.length) {\n        this.checkedTreeNodes = this._checkedNodes = this.checkedTreeNodes.filter(function (item) {\n          return value.some(function (i) {\n            return i.value === item.node.props.value;\n          });\n        });\n      }\n    }\n\n    this.fireChange(value, {\n      triggerValue: selectedVal,\n      clear: true\n    });\n  };\n\n  Select.prototype.openIfHasChildren = function openIfHasChildren() {\n    var props = this.props;\n\n    if (React.Children.count(props.children) || isSingleMode(props)) {\n      this.setOpenState(true);\n    }\n  };\n\n  Select.prototype.fireChange = function fireChange(value, extraInfo) {\n    var _this6 = this;\n\n    var props = this.props;\n    var vals = value.map(function (i) {\n      return i.value;\n    });\n    var sv = this.state.value.map(function (i) {\n      return i.value;\n    });\n\n    if (vals.length !== sv.length || !vals.every(function (val, index) {\n      return sv[index] === val;\n    })) {\n      var ex = {\n        preValue: [].concat(this.state.value)\n      };\n\n      if (extraInfo) {\n        assign(ex, extraInfo);\n      }\n\n      var labs = null;\n      var vls = value;\n\n      if (!this.isLabelInValue()) {\n        labs = value.map(function (i) {\n          return i.label;\n        });\n        vls = vls.map(function (v) {\n          return v.value;\n        });\n      } else if (this.halfCheckedValues && this.halfCheckedValues.length) {\n        this.halfCheckedValues.forEach(function (i) {\n          if (!vls.some(function (v) {\n            return v.value === i.value;\n          })) {\n            vls.push(i);\n          }\n        });\n      }\n\n      if (props.treeCheckable && ex.clear) {\n        var treeData = this.renderedTreeData || props.children;\n        ex.allCheckedNodes = flatToHierarchy(filterAllCheckedData(vals, treeData));\n      }\n\n      if (props.treeCheckable && this.state.inputValue) {\n        var _vls = [].concat(this.state.value);\n\n        if (ex.checked) {\n          value.forEach(function (i) {\n            if (_vls.every(function (ii) {\n              return ii.value !== i.value;\n            })) {\n              _vls.push(_extends({}, i));\n            }\n          });\n        } else {\n          var index = void 0;\n\n          var includeVal = _vls.some(function (i, ind) {\n            if (i.value === ex.triggerValue) {\n              index = ind;\n              return true;\n            }\n          });\n\n          if (includeVal) {\n            _vls.splice(index, 1);\n          }\n        }\n\n        vls = _vls;\n\n        if (!this.isLabelInValue()) {\n          labs = _vls.map(function (v) {\n            return v.label;\n          });\n          vls = _vls.map(function (v) {\n            return v.value;\n          });\n        }\n      }\n\n      this._savedValue = isMultipleOrTags(props) ? vls : vls[0];\n      props.onChange(this._savedValue, labs, ex);\n\n      if (!('value' in props)) {\n        this._cacheTreeNodesStates = false;\n        this.setState({\n          value: this.getValue(props, toArray(this._savedValue).map(function (v, i) {\n            return _this6.isLabelInValue() ? v : {\n              value: v,\n              label: labs && labs[i]\n            };\n          }))\n        });\n      }\n    }\n  };\n\n  Select.prototype.isLabelInValue = function isLabelInValue() {\n    var _props3 = this.props,\n        treeCheckable = _props3.treeCheckable,\n        treeCheckStrictly = _props3.treeCheckStrictly,\n        labelInValue = _props3.labelInValue;\n\n    if (treeCheckable && treeCheckStrictly) {\n      return true;\n    }\n\n    return labelInValue || false;\n  };\n\n  Select.prototype.renderTopControlNode = function renderTopControlNode() {\n    var _this7 = this;\n\n    var value = this.state.value;\n    var props = this.props;\n    var choiceTransitionName = props.choiceTransitionName,\n        prefixCls = props.prefixCls,\n        maxTagTextLength = props.maxTagTextLength; // single and not combobox, input is inside dropdown\n\n    if (isSingleMode(props)) {\n      var innerNode = React.createElement('span', {\n        key: 'placeholder',\n        className: prefixCls + '-selection__placeholder'\n      }, props.placeholder);\n\n      if (value.length) {\n        innerNode = React.createElement('span', {\n          key: 'value',\n          title: value[0].label,\n          className: prefixCls + '-selection-selected-value'\n        }, value[0].label);\n      }\n\n      return React.createElement('span', {\n        className: prefixCls + '-selection__rendered'\n      }, innerNode);\n    }\n\n    var selectedValueNodes = [];\n\n    if (isMultipleOrTags(props)) {\n      selectedValueNodes = value.map(function (singleValue) {\n        var content = singleValue.label;\n        var title = content;\n\n        if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {\n          content = content.slice(0, maxTagTextLength) + '...';\n        }\n\n        return React.createElement('li', _extends({\n          style: UNSELECTABLE_STYLE\n        }, UNSELECTABLE_ATTRIBUTE, {\n          onMouseDown: preventDefaultEvent,\n          className: prefixCls + '-selection__choice',\n          key: singleValue.value,\n          title: title\n        }), React.createElement('span', {\n          className: prefixCls + '-selection__choice__remove',\n          onClick: _this7.removeSelected.bind(_this7, singleValue.value)\n        }), React.createElement('span', {\n          className: prefixCls + '-selection__choice__content'\n        }, content));\n      });\n    }\n\n    selectedValueNodes.push(React.createElement('li', {\n      className: prefixCls + '-search ' + prefixCls + '-search--inline',\n      key: '__input'\n    }, this.getInputElement()));\n    var className = prefixCls + '-selection__rendered';\n\n    if (isMultipleOrTags(props) && choiceTransitionName) {\n      return React.createElement(Animate, {\n        className: className,\n        component: 'ul',\n        transitionName: choiceTransitionName,\n        onLeave: this.onChoiceAnimationLeave\n      }, selectedValueNodes);\n    }\n\n    return React.createElement('ul', {\n      className: className\n    }, selectedValueNodes);\n  };\n\n  Select.prototype.renderTreeData = function renderTreeData(props) {\n    var validProps = props || this.props;\n\n    if (validProps.treeData) {\n      if (props && props.treeData === this.props.treeData && this.renderedTreeData) {\n        // cache and use pre data.\n        this._cachetreeData = true;\n        return this.renderedTreeData;\n      }\n\n      this._cachetreeData = false;\n      var treeData = [].concat(validProps.treeData); // process treeDataSimpleMode\n\n      if (validProps.treeDataSimpleMode) {\n        var simpleFormat = {\n          id: 'id',\n          pId: 'pId',\n          rootPId: null\n        };\n\n        if (Object.prototype.toString.call(validProps.treeDataSimpleMode) === '[object Object]') {\n          assign(simpleFormat, validProps.treeDataSimpleMode);\n        }\n\n        treeData = processSimpleTreeData(treeData, simpleFormat);\n      }\n\n      return loopTreeData(treeData);\n    }\n  };\n\n  Select.prototype.render = function render() {\n    var _rootCls;\n\n    var props = this.props;\n    var multiple = isMultipleOrTags(props);\n    var state = this.state;\n    var className = props.className,\n        disabled = props.disabled,\n        allowClear = props.allowClear,\n        prefixCls = props.prefixCls;\n    var ctrlNode = this.renderTopControlNode();\n    var extraSelectionProps = {};\n\n    if (!isMultipleOrTagsOrCombobox(props)) {\n      extraSelectionProps = {\n        onKeyDown: this.onKeyDown,\n        tabIndex: 0\n      };\n    }\n\n    var rootCls = (_rootCls = {}, _rootCls[className] = !!className, _rootCls[prefixCls] = 1, _rootCls[prefixCls + '-open'] = state.open, _rootCls[prefixCls + '-focused'] = state.open || state.focused, _rootCls[prefixCls + '-disabled'] = disabled, _rootCls[prefixCls + '-enabled'] = !disabled, _rootCls[prefixCls + '-allow-clear'] = !!props.allowClear, _rootCls);\n    var clear = React.createElement('span', {\n      key: 'clear',\n      className: prefixCls + '-selection__clear',\n      onClick: this.onClearSelection\n    });\n    return React.createElement(SelectTrigger, _extends({}, props, {\n      treeNodes: props.children,\n      treeData: this.renderedTreeData,\n      _cachetreeData: this._cachetreeData,\n      _treeNodesStates: this._treeNodesStates,\n      halfCheckedValues: this.halfCheckedValues,\n      multiple: multiple,\n      disabled: disabled,\n      visible: state.open,\n      inputValue: state.inputValue,\n      inputElement: this.getInputElement(),\n      value: state.value,\n      onDropdownVisibleChange: this.onDropdownVisibleChange,\n      getPopupContainer: props.getPopupContainer,\n      onSelect: this.onSelect,\n      ref: 'trigger'\n    }), React.createElement('span', {\n      style: props.style,\n      onClick: props.onClick,\n      className: classnames(rootCls)\n    }, React.createElement('span', _extends({\n      ref: 'selection',\n      key: 'selection',\n      className: prefixCls + '-selection\\n            ' + prefixCls + '-selection--' + (multiple ? 'multiple' : 'single'),\n      role: 'combobox',\n      'aria-autocomplete': 'list',\n      'aria-haspopup': 'true',\n      'aria-expanded': state.open\n    }, extraSelectionProps), ctrlNode, allowClear && this.state.value.length && this.state.value[0].value ? clear : null, multiple || !props.showArrow ? null : React.createElement('span', {\n      key: 'arrow',\n      className: prefixCls + '-arrow',\n      style: {\n        outline: 'none'\n      }\n    }, React.createElement('b', null)), multiple ? this.getSearchPlaceholderElement(!!this.state.inputValue || this.state.value.length) : null)));\n  };\n\n  return Select;\n}(Component);\n\nSelect.propTypes = SelectPropTypes;\nSelect.defaultProps = {\n  prefixCls: 'rc-tree-select',\n  filterTreeNode: filterFn,\n  showSearch: true,\n  allowClear: false,\n  placeholder: '',\n  searchPlaceholder: '',\n  labelInValue: false,\n  onClick: noop,\n  onChange: noop,\n  onSelect: noop,\n  onDeselect: noop,\n  onSearch: noop,\n  showArrow: true,\n  dropdownMatchSelectWidth: true,\n  dropdownStyle: {},\n  onDropdownVisibleChange: function onDropdownVisibleChange() {\n    return true;\n  },\n  notFoundContent: 'Not Found',\n  showCheckedStrategy: SHOW_CHILD,\n  // skipHandleInitValue: false, // Deprecated (use treeCheckStrictly)\n  treeCheckStrictly: false,\n  treeIcon: false,\n  treeLine: false,\n  treeDataSimpleMode: false,\n  treeDefaultExpandAll: false,\n  treeCheckable: false,\n  treeNodeFilterProp: 'value',\n  treeNodeLabelProp: 'title'\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this8 = this;\n\n  this.onInputChange = function (event) {\n    var val = event.target.value;\n    var props = _this8.props;\n\n    _this8.setState({\n      inputValue: val,\n      open: true\n    });\n\n    if (props.treeCheckable && !val) {\n      _this8.setState({\n        value: _this8.getValue(props, [].concat(_this8.state.value), false)\n      });\n    }\n\n    props.onSearch(val);\n  };\n\n  this.onDropdownVisibleChange = function (open) {\n    // selection inside combobox cause click\n    if (!open && document.activeElement === _this8.getInputDOMNode()) {} // return;\n    // this.setOpenState(open);\n    // setTimeout, then have animation. why?\n\n\n    setTimeout(function () {\n      _this8.setOpenState(open, undefined, !open);\n    }, 10);\n  };\n\n  this.onKeyDown = function (event) {\n    var props = _this8.props;\n\n    if (props.disabled) {\n      return;\n    }\n\n    var keyCode = event.keyCode;\n\n    if (_this8.state.open && !_this8.getInputDOMNode()) {\n      _this8.onInputKeyDown(event);\n    } else if (keyCode === KeyCode.ENTER || keyCode === KeyCode.DOWN) {\n      _this8.setOpenState(true);\n\n      event.preventDefault();\n    }\n  };\n\n  this.onInputKeyDown = function (event) {\n    var props = _this8.props;\n\n    if (props.disabled) {\n      return;\n    }\n\n    var state = _this8.state;\n    var keyCode = event.keyCode;\n\n    if (isMultipleOrTags(props) && !event.target.value && keyCode === KeyCode.BACKSPACE) {\n      var value = state.value.concat();\n\n      if (value.length) {\n        var popValue = value.pop();\n\n        _this8.removeSelected(_this8.isLabelInValue() ? popValue : popValue.value);\n      }\n\n      return;\n    }\n\n    if (keyCode === KeyCode.DOWN) {\n      if (!state.open) {\n        _this8.openIfHasChildren();\n\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n    } else if (keyCode === KeyCode.ESC) {\n      if (state.open) {\n        _this8.setOpenState(false);\n\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      return;\n    }\n  };\n\n  this.onSelect = function (selectedKeys, info) {\n    if (info.selected === false) {\n      _this8.onDeselect(info);\n\n      return;\n    }\n\n    var item = info.node;\n    var value = _this8.state.value;\n    var props = _this8.props;\n    var selectedValue = getValuePropValue(item);\n\n    var selectedLabel = _this8.getLabelFromNode(item);\n\n    var event = selectedValue;\n\n    if (_this8.isLabelInValue()) {\n      event = {\n        value: event,\n        label: selectedLabel\n      };\n    }\n\n    props.onSelect(event, item, info);\n    var checkEvt = info.event === 'check';\n\n    if (isMultipleOrTags(props)) {\n      _this8.clearSearchInput();\n\n      if (checkEvt) {\n        value = _this8.getCheckedNodes(info, props).map(function (n) {\n          return {\n            value: getValuePropValue(n),\n            label: _this8.getLabelFromNode(n)\n          };\n        });\n      } else {\n        if (value.some(function (i) {\n          return i.value === selectedValue;\n        })) {\n          return;\n        }\n\n        value = value.concat([{\n          value: selectedValue,\n          label: selectedLabel\n        }]);\n      }\n    } else {\n      if (value.length && value[0].value === selectedValue) {\n        _this8.setOpenState(false);\n\n        return;\n      }\n\n      value = [{\n        value: selectedValue,\n        label: selectedLabel\n      }];\n\n      _this8.setOpenState(false);\n    }\n\n    var extraInfo = {\n      triggerValue: selectedValue,\n      triggerNode: item\n    };\n\n    if (checkEvt) {\n      extraInfo.checked = info.checked; // if inputValue existing, tree is checkStrictly\n\n      extraInfo.allCheckedNodes = props.treeCheckStrictly || _this8.state.inputValue ? info.checkedNodes : flatToHierarchy(info.checkedNodesPositions);\n      _this8._checkedNodes = info.checkedNodesPositions;\n      var _tree = _this8.refs.trigger.popupEle;\n      _this8._treeNodesStates = _tree.checkKeys;\n    } else {\n      extraInfo.selected = info.selected;\n    }\n\n    _this8.fireChange(value, extraInfo);\n\n    if (props.inputValue === null) {\n      _this8.setState({\n        inputValue: ''\n      });\n    }\n  };\n\n  this.onDeselect = function (info) {\n    _this8.removeSelected(getValuePropValue(info.node));\n\n    if (!isMultipleOrTags(_this8.props)) {\n      _this8.setOpenState(false);\n    } else {\n      _this8.clearSearchInput();\n    }\n  };\n\n  this.onPlaceholderClick = function () {\n    _this8.getInputDOMNode().focus();\n  };\n\n  this.onClearSelection = function (event) {\n    var props = _this8.props;\n    var state = _this8.state;\n\n    if (props.disabled) {\n      return;\n    }\n\n    event.stopPropagation();\n    _this8._cacheTreeNodesStates = 'no';\n    _this8._checkedNodes = [];\n\n    if (state.inputValue || state.value.length) {\n      _this8.setOpenState(false);\n\n      if (typeof props.inputValue === 'undefined') {\n        _this8.setState({\n          inputValue: ''\n        }, function () {\n          _this8.fireChange([]);\n        });\n      } else {\n        _this8.fireChange([]);\n      }\n    }\n  };\n\n  this.onChoiceAnimationLeave = function () {\n    _this8.refs.trigger.refs.trigger.forcePopupAlign();\n  };\n};\n\nSelect.SHOW_ALL = SHOW_ALL;\nSelect.SHOW_PARENT = SHOW_PARENT;\nSelect.SHOW_CHILD = SHOW_CHILD;\nexport default Select;","map":null,"metadata":{},"sourceType":"module"}