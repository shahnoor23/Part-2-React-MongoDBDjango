{"ast":null,"code":"import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport addEventListener from 'rc-util/es/Dom/addEventListener';\nimport Affix from '../affix';\nimport getScroll from '../_util/getScroll';\nimport getRequestAnimationFrame from '../_util/getRequestAnimationFrame';\n\nfunction getDefaultTarget() {\n  return window;\n}\n\nfunction getOffsetTop(element) {\n  if (!element) {\n    return 0;\n  }\n\n  if (!element.getClientRects().length) {\n    return 0;\n  }\n\n  var rect = element.getBoundingClientRect();\n\n  if (rect.width || rect.height) {\n    var doc = element.ownerDocument;\n    var docElem = doc.documentElement;\n    return rect.top - docElem.clientTop;\n  }\n\n  return rect.top;\n}\n\nfunction easeInOutCubic(t, b, c, d) {\n  var cc = c - b;\n  t /= d / 2;\n\n  if (t < 1) {\n    return cc / 2 * t * t * t + b;\n  }\n\n  return cc / 2 * ((t -= 2) * t * t + 2) + b;\n}\n\nvar reqAnimFrame = getRequestAnimationFrame();\n\nfunction scrollTo(href) {\n  var offsetTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var target = arguments[2];\n  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n  var scrollTop = getScroll(target(), true);\n  var targetElement = document.getElementById(href.substring(1));\n\n  if (!targetElement) {\n    return;\n  }\n\n  var eleOffsetTop = getOffsetTop(targetElement);\n  var targetScrollTop = scrollTop + eleOffsetTop - offsetTop;\n  var startTime = Date.now();\n\n  var frameFunc = function frameFunc() {\n    var timestamp = Date.now();\n    var time = timestamp - startTime;\n    window.scrollTo(window.pageXOffset, easeInOutCubic(time, scrollTop, targetScrollTop, 450));\n\n    if (time < 450) {\n      reqAnimFrame(frameFunc);\n    } else {\n      callback();\n    }\n  };\n\n  reqAnimFrame(frameFunc);\n  history.pushState(null, '', href);\n}\n\nvar Anchor = function (_React$Component) {\n  _inherits(Anchor, _React$Component);\n\n  function Anchor(props) {\n    _classCallCheck(this, Anchor);\n\n    var _this = _possibleConstructorReturn(this, (Anchor.__proto__ || Object.getPrototypeOf(Anchor)).call(this, props));\n\n    _this.handleScroll = function () {\n      if (_this.animating) {\n        return;\n      }\n\n      var _this$props = _this.props,\n          offsetTop = _this$props.offsetTop,\n          bounds = _this$props.bounds;\n\n      _this.setState({\n        activeLink: _this.getCurrentAnchor(offsetTop, bounds)\n      });\n    };\n\n    _this.handleScrollTo = function (link) {\n      var _this$props2 = _this.props,\n          offsetTop = _this$props2.offsetTop,\n          _this$props2$target = _this$props2.target,\n          target = _this$props2$target === undefined ? getDefaultTarget : _this$props2$target;\n      _this.animating = true;\n\n      _this.setState({\n        activeLink: link\n      });\n\n      scrollTo(link, offsetTop, target, function () {\n        _this.animating = false;\n      });\n    };\n\n    _this.updateInk = function () {\n      if (typeof document === 'undefined') {\n        return;\n      }\n\n      var prefixCls = _this.props.prefixCls;\n      var linkNode = ReactDOM.findDOMNode(_this).getElementsByClassName(prefixCls + '-link-title-active')[0];\n\n      if (linkNode) {\n        _this.refs.ink.style.top = linkNode.offsetTop + linkNode.clientHeight / 2 - 4.5 + 'px';\n      }\n    };\n\n    _this.state = {\n      activeLink: null\n    };\n    _this.links = [];\n    return _this;\n  }\n\n  _createClass(Anchor, [{\n    key: 'getChildContext',\n    value: function getChildContext() {\n      var _this2 = this;\n\n      return {\n        antAnchor: {\n          registerLink: function registerLink(link) {\n            if (!_this2.links.includes(link)) {\n              _this2.links.push(link);\n            }\n          },\n          unregisterLink: function unregisterLink(link) {\n            var index = _this2.links.indexOf(link);\n\n            if (index !== -1) {\n              _this2.links.splice(index, 1);\n            }\n          },\n          activeLink: this.state.activeLink,\n          scrollTo: this.handleScrollTo\n        }\n      };\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var getTarget = this.props.target || getDefaultTarget;\n      this.scrollEvent = addEventListener(getTarget(), 'scroll', this.handleScroll);\n      this.handleScroll();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.scrollEvent) {\n        this.scrollEvent.remove();\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.updateInk();\n    }\n  }, {\n    key: 'getCurrentAnchor',\n    value: function getCurrentAnchor() {\n      var offsetTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n      var activeLink = '';\n\n      if (typeof document === 'undefined') {\n        return activeLink;\n      }\n\n      var linkSections = [];\n      this.links.forEach(function (link) {\n        var target = document.getElementById(link.substring(1));\n\n        if (target && getOffsetTop(target) < offsetTop + bounds) {\n          var top = getOffsetTop(target);\n          linkSections.push({\n            link: link,\n            top: top\n          });\n        }\n      });\n\n      if (linkSections.length) {\n        var maxSection = linkSections.reduce(function (prev, curr) {\n          return curr.top > prev.top ? curr : prev;\n        });\n        return maxSection.link;\n      }\n\n      return '';\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          prefixCls = _props.prefixCls,\n          _props$className = _props.className,\n          className = _props$className === undefined ? '' : _props$className,\n          style = _props.style,\n          offsetTop = _props.offsetTop,\n          affix = _props.affix,\n          showInkInFixed = _props.showInkInFixed,\n          children = _props.children;\n      var activeLink = this.state.activeLink;\n      var inkClass = classNames(prefixCls + '-ink-ball', {\n        visible: activeLink\n      });\n      var wrapperClass = classNames(className, prefixCls + '-wrapper');\n      var anchorClass = classNames(prefixCls, {\n        'fixed': !affix && !showInkInFixed\n      });\n      var anchorContent = React.createElement('div', {\n        className: wrapperClass,\n        style: style\n      }, React.createElement('div', {\n        className: anchorClass\n      }, React.createElement('div', {\n        className: prefixCls + '-ink'\n      }, React.createElement('span', {\n        className: inkClass,\n        ref: 'ink'\n      })), children));\n      return !affix ? anchorContent : React.createElement(Affix, {\n        offsetTop: offsetTop\n      }, anchorContent);\n    }\n  }]);\n\n  return Anchor;\n}(React.Component);\n\nexport default Anchor;\nAnchor.defaultProps = {\n  prefixCls: 'ant-anchor',\n  affix: true,\n  showInkInFixed: false\n};\nAnchor.childContextTypes = {\n  antAnchor: PropTypes.object\n};","map":null,"metadata":{},"sourceType":"module"}